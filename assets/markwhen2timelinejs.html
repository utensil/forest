<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markwhen â†’ TimelineJS (v0.16.3 Fixed + Full Screen)</title>
    <!-- TimelineJS (stable) -->
    <link rel="stylesheet" href="https://cdn.knightlab.com/libs/timeline3/3.9.0/css/timeline.css">
    <script src="https://cdn.knightlab.com/libs/timeline3/3.9.0/js/timeline.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .editor-container {
            width: 40%;
            height: 100%;
            border-right: 1px solid #eee;
            padding: 1rem;
        }

        .timeline-container {
            width: 60%;
            height: 100%;
            padding: 1rem;
            overflow: auto;
            position: relative;
        }

        #markwhen-editor {
            width: 100%;
            height: 95%;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            line-height: 1.6;
            tab-size: 4;
        }

        h3 {
            margin-bottom: 0.5rem;
            color: #333;
            display: inline-block;
        }

        .instructions {
            font-size: 12px;
            color: #666;
            margin-bottom: 1rem;
        }

        .error-message {
            color: #dc3545;
            font-size: 12px;
            margin-top: 0.5rem;
            display: block;
        }

        .success-message {
            color: #28a745;
            font-size: 12px;
            margin-top: 0.5rem;
            display: none;
        }

        .empty-state {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        /* Full Screen Button Styles */
        #fullscreen-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background-color 0.2s;
        }

        #fullscreen-btn:hover {
            background-color: #0056b3;
        }

        #fullscreen-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Full Screen Mode Adjustments */
        .timeline-container:-webkit-full-screen {
            width: 100vw !important;
            height: 100vh !important;
            padding: 2rem;
            z-index: 1000;
            background-color: white;
        }

        .timeline-container:fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            padding: 2rem;
            z-index: 1000;
            background-color: white;
        }

        .timeline-container:-webkit-full-screen #timeline {
            height: calc(100vh - 60px) !important;
        }

        .timeline-container:fullscreen #timeline {
            height: calc(100vh - 60px) !important;
        }

        /* Color Palette Dropdown Styles */
        .palette-selector {
            position: relative;
            display: inline-block;
        }

        .palette-dropdown {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px 32px 8px 12px;
            font-size: 12px;
            cursor: pointer;
            min-width: 200px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .palette-dropdown:hover {
            border-color: #999;
        }

        .palette-dropdown.open {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .dropdown-arrow {
            width: 16px;
            height: 16px;
            transition: transform 0.2s;
        }

        .dropdown-arrow.open {
            transform: rotate(180deg);
        }

        .palette-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 1000;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }

        .palette-options.open {
            display: block;
        }

        .palette-option {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #f0f0f0;
        }

        .palette-option:last-child {
            border-bottom: none;
        }

        .palette-option:hover {
            background-color: #f8f9fa;
        }

        .palette-option.selected {
            background-color: #e3f2fd;
        }

        .color-preview {
            display: inline-flex;
            gap: 2px;
        }

        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Editor -->
        <div class="editor-container">
            <h3>Markwhen Editor</h3>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <p class="instructions">Supports sections, groups, tags, tasks, media, links</p>
                <div>
                    <label for="color-palette" style="font-size: 12px; color: #666; margin-right: 0.5rem;">Color
                        Palette:</label>
                    <div class="palette-selector">
                        <div class="palette-dropdown" id="palette-dropdown">
                            <span id="selected-palette">Meadow Green</span>
                            <svg class="dropdown-arrow" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
                                <path stroke="#6b7280" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 8l4 4 4-4"/>
                            </svg>
                        </div>
                        <div class="palette-options" id="palette-options">
                            <!-- Options will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            <textarea id="markwhen-editor">---
title: 2024 Product Launch Timeline
timezone: America/Los_Angeles
#Launch: #2196F3
#Design: #FF9800
#Development: #4CAF50
#Project1: #3d6bc7

timeline:
  style:
    row:
      height: 30
    event:
      bar:
        height: 12
        rx: 3
---

section Welcome #welcome
now: This example showcases markwhen features with auto-generated tag colors #welcome

Feel free to modify this timeline to start making your own #welcome

For more info, view [docs](https://docs.markwhen.com) or join [discord](https://discord.gg/3rTpUD94ac) #welcome
endSection

section Q1 2024: Preparation
group Planning #Launch
2024-01-10 to 2024-01-20: Finalize Product Requirements
  id: requirements
- [x] Review 2023 user feedback
- [ ] Draft PRD v1.0
contact: product@example.com
assignees: [Alice (PM), Bob (Design Lead)]

in 5 days after !requirements: UX Design Kickoff #Research
![UX Workshop](https://picsum.photos/id/1/800/400)
location: Virtual (Zoom Link: https://example.com/ux-kickoff)
endGroup

group Design #Design
Feb 1 2024 to Feb 29 2024: Wireframe & Prototype #UI
- [x] Homepage wireframe
- [x] User flow diagrams
- [ ] High-fidelity prototype
assignees: [Bob, Charlie (UX Designer)]
endGroup

section Q2 2024: Development & Testing
group Development #Development
Mar 1 2024 to Apr 30 2024: Frontend Development #Frontend
  id: frontend
[View Tech Spec](https://example.com/tech-spec)
contact: Dave (Tech Lead) â†’ dave@example.com

!frontend.start / !frontend.end: Continuous testing #Testing
endGroup

group QA #Testing
May 1 2024 to May 15 2024: QA Testing #Testing
- [ ] Functional testing
- [ ] Performance testing
- [ ] Cross-browser compatibility
location: QA Lab (Floor 3)
endGroup

section Q3 2024: Launch
group Marketing #Marketing
Jun 1 2024: Product Launch Event #Marketing
![Launch Teaser](https://picsum.photos/id/20/800/400)
contact: Emma (Marketing) â†’ emma@example.com
endGroup
            </textarea>
            <div id="parser-load-error" class="error-message">Loading parser... (refresh if stuck)</div>
            <div id="parse-error" class="error-message" style="display: none;">Parsing failed! Check console.</div>
            <div id="success-message" class="success-message">Parsing successful â†’ Timeline updated</div>
        </div>

        <!-- Timeline Preview (with Full Screen Button) -->
        <div class="timeline-container">
            <h3>TimelineJS Preview (Auto-Updates)</h3>
            <!-- Full Screen Button -->
            <button id="fullscreen-btn" aria-label="Toggle full screen">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M10 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Full Screen
            </button>
            <div id="timeline" style="width: 100%; height: calc(100% - 40px);">
                <div class="empty-state">Loading timeline...</div>
            </div>
        </div>
    </div>

    <script type="module">
        // 1. Color Palettes for Auto-Generated Tag Colors
        const COLOR_PALETTES = {
            markwhen: [
                "rgb(22, 163, 76)",
                "rgb(2, 132, 199)",
                "rgb(212, 50, 56)",
                "rgb(242, 202, 45)",
                "rgb(80, 73, 229)",
                "rgb(145, 57, 234)",
                "rgb(214, 45, 123)",
                "rgb(234, 88, 11)",
                "rgb(168, 162, 157)",
                "rgb(255, 255, 255)",
                "rgb(0, 0, 0)",
            ],
            meadow: [
                "#d9ed92", // Lime Cream
                "#b5e48c", // Light Green
                "#99d98c", // Willow Green
                "#76c893", // Emerald
                "#52b69a", // Ocean Mist
                "#34a0a4", // Tropical Teal
                "#168aad", // Bondi Blue
                "#1a759f", // Cerulean
                "#1e6091", // Baltic Blue
                "#184e77", // Yale Blue
            ],
            ocean: [
                "#03045e", // Deep Twilight
                "#023e8a", // French Blue
                "#0077b6", // Bright Teal Blue
                "#0096c7", // Blue Green
                "#00b4d8", // Turquoise Surf
                "#48cae4", // Sky Aqua
                "#90e0ef", // Frosted Blue
                "#ade8f4", // Frosted Blue (lighter)
                "#caf0f8", // Light Cyan
            ],
            earthy: [
                "#797d62", // Dusty Olive
                "#9b9b7a", // Palm Leaf
                "#baa587", // Khaki Beige
                "#d9ae94", // Desert Sand
                "#f1dca7", // Soft Peach
                "#ffcb69", // Golden Pollen
                "#e8ac65", // Sunlit Clay
                "#d08c60", // Toasted Almond
                "#b58463", // Faded Copper
                "#997b66", // Dusty Taupe
            ],
            sunset: [
                "#f94144", // Strawberry Red
                "#f3722c", // Pumpkin Spice
                "#f8961e", // Carrot Orange
                "#f9c74f", // Tuscan Sun
                "#90be6d", // Willow Green
                "#43aa8b", // Seaweed
                "#577590", // Blue Slate
            ],
            vibrant: [
                "#f94144", // Strawberry Red
                "#f3722c", // Pumpkin Spice
                "#f8961e", // Carrot Orange
                "#f9844a", // Atomic Tangerine
                "#f9c74f", // Tuscan Sun
                "#90be6d", // Willow Green
                "#43aa8b", // Seaweed
                "#4d908e", // Dark Cyan
                "#577590", // Blue Slate
                "#277da1", // Cerulean
            ]
        };

        // 2. Force show all logs + Import dependencies
        console.log('ðŸ”´ DEBUG: Script started - v0.16.3 compatibility + Full Screen');
        let parseMarkwhen;
        let dateFns;
        const parserLoadError = document.getElementById('parser-load-error');

        try {
            // Import date-fns
            dateFns = await import('https://esm.sh/date-fns@2.30.0');
            console.log('âœ… DEBUG: date-fns loaded', {hasParse: !!dateFns.parse});

            // Import Markwhen Parser v0.16.3 (force bundle)
            const parserModule = await import('https://esm.sh/@markwhen/parser@0.16.3?bundle');
            parseMarkwhen = parserModule.parse;
            console.log('âœ… DEBUG: Markwhen Parser v0.16.3 loaded', {isFunction: typeof parseMarkwhen === 'function'});

            parserLoadError.style.display = 'none';
            
            // Initialize custom dropdown with color previews
            initializeDropdown();
        } catch (err) {
            parserLoadError.textContent = `Dependency load failed: ${err.message}`;
            console.error('âŒ DEBUG: Dependency error:', err);
        }

        // 2. DOM Elements and State
        const editor = document.getElementById('markwhen-editor');
        const parseError = document.getElementById('parse-error');
        const successMessage = document.getElementById('success-message');
        const timelineContainer = document.getElementById('timeline');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        let timelineInstance = null;
        let currentPalette = 'meadow';

        // 3. Initialize Custom Dropdown
        function initializeDropdown() {
            console.log('ðŸ”§ DEBUG: Initializing dropdown');
            
            const paletteDropdown = document.getElementById('palette-dropdown');
            const paletteOptions = document.getElementById('palette-options');
            const selectedPalette = document.getElementById('selected-palette');
            
            if (!paletteDropdown || !paletteOptions || !selectedPalette) {
                console.error('âŒ DEBUG: Dropdown elements not found', {
                    paletteDropdown: !!paletteDropdown,
                    paletteOptions: !!paletteOptions,
                    selectedPalette: !!selectedPalette
                });
                return;
            }

            const paletteNames = {
                markwhen: 'Markwhen Default',
                meadow: 'Meadow Green',
                ocean: 'Ocean Blue Serenity',
                earthy: 'Earthy Tones',
                sunset: 'Sunset Glow',
                vibrant: 'Vibrant Tones'
            };

            // Populate options
            paletteOptions.innerHTML = '';
            Object.entries(COLOR_PALETTES).forEach(([key, colors]) => {
                const option = document.createElement('div');
                option.className = `palette-option ${key === currentPalette ? 'selected' : ''}`;
                option.dataset.value = key;
                
                const colorPreview = colors.slice(0, 6).map(color => 
                    `<div class="color-dot" style="background-color: ${color}"></div>`
                ).join('');
                
                option.innerHTML = `
                    <span>${paletteNames[key]}</span>
                    <div class="color-preview">${colorPreview}</div>
                `;
                
                option.addEventListener('click', () => {
                    console.log('ðŸŽ¨ DEBUG: Palette selected:', key);
                    selectPalette(key);
                });
                paletteOptions.appendChild(option);
            });

            // Toggle dropdown
            paletteDropdown.addEventListener('click', (e) => {
                console.log('ðŸ”§ DEBUG: Dropdown clicked');
                e.stopPropagation();
                toggleDropdown();
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!paletteDropdown.contains(e.target) && !paletteOptions.contains(e.target)) {
                    closeDropdown();
                }
            });
            
            console.log('âœ… DEBUG: Dropdown initialized successfully');
        }

        function toggleDropdown() {
            const paletteOptions = document.getElementById('palette-options');
            const paletteDropdown = document.getElementById('palette-dropdown');
            
            const isOpen = paletteOptions.classList.contains('open');
            console.log('ðŸ”§ DEBUG: Toggle dropdown, currently open:', isOpen);
            
            if (isOpen) {
                closeDropdown();
            } else {
                openDropdown();
            }
        }

        function openDropdown() {
            const paletteOptions = document.getElementById('palette-options');
            const paletteDropdown = document.getElementById('palette-dropdown');
            
            console.log('ðŸ”§ DEBUG: Opening dropdown');
            paletteOptions.classList.add('open');
            paletteDropdown.classList.add('open');
            paletteDropdown.querySelector('.dropdown-arrow').classList.add('open');
        }

        function closeDropdown() {
            const paletteOptions = document.getElementById('palette-options');
            const paletteDropdown = document.getElementById('palette-dropdown');
            
            console.log('ðŸ”§ DEBUG: Closing dropdown');
            paletteOptions.classList.remove('open');
            paletteDropdown.classList.remove('open');
            paletteDropdown.querySelector('.dropdown-arrow').classList.remove('open');
        }

        function selectPalette(key) {
            const selectedPalette = document.getElementById('selected-palette');
            
            currentPalette = key;
            const paletteNames = {
                markwhen: 'Markwhen Default',
                meadow: 'Meadow Green',
                ocean: 'Ocean Blue Serenity',
                earthy: 'Earthy Tones',
                sunset: 'Sunset Glow',
                vibrant: 'Vibrant Tones'
            };
            
            selectedPalette.textContent = paletteNames[key];
            
            // Update selected state
            const paletteOptions = document.getElementById('palette-options');
            paletteOptions.querySelectorAll('.palette-option').forEach(option => {
                option.classList.toggle('selected', option.dataset.value === key);
            });
            
            closeDropdown();
            updateTimeline();
        }

        // 4. Update Color Preview (now unused but keeping for compatibility)
        function updateColorPreview() {
            // This function is no longer needed but kept for compatibility
        }

        // 5. Full Screen Toggle Functionality
        function toggleFullscreen() {
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;

            if (!isFullscreen) {
                // Enter full screen
                if (timelineContainer.parentElement.requestFullscreen) {
                    timelineContainer.parentElement.requestFullscreen();
                } else if (timelineContainer.parentElement.webkitRequestFullscreen) {
                    timelineContainer.parentElement.webkitRequestFullscreen();
                }
                console.log('ðŸ“º DEBUG: Entering full screen');
            } else {
                // Exit full screen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                console.log('ðŸ“º DEBUG: Exiting full screen');
            }
        }

        // Update button text/icon when full screen state changes
        function updateFullscreenButton() {
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
            const svg = fullscreenBtn.querySelector('svg');

            if (isFullscreen) {
                fullscreenBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 10h4m-4 0v4m-6 2a9 9 0 1118 0 9 9 0 01-18 0z" />
                    </svg>
                    Exit Full Screen
                `;
            } else {
                fullscreenBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Full Screen
                `;
            }

            // Refresh timeline layout to fit new dimensions
            if (timelineInstance) {
                timelineInstance.updateDisplay();
                console.log('ðŸ“º DEBUG: Timeline layout refreshed for full screen');
            }
        }

        // Add full screen event listeners
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);

        // 6. Date Normalization (simplified for reliability)
        function normalizeDate(dateStr) {
            if (!dateStr || !dateFns) {
                console.log('âš ï¸ DEBUG: normalizeDate skipped', {reason: !dateStr ? 'No date' : 'dateFns missing'});
                return null;
            }
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return {
                    year: date.getFullYear(),
                    month: date.getMonth() + 1,
                    day: date.getDate(),
                    hour: 0,
                    minute: 0
                };
            } catch (err) {
                console.error('âŒ DEBUG: Date parse failed', {input: dateStr, error: err.message});
                return null;
            }
        }

        // 7. Extract Tasks (simplified for v0.16.3)
        function extractTasks(supplemental) {
            const tasks = [];
            if (!Array.isArray(supplemental)) return tasks;
            supplemental.forEach(item => {
                if (item.type === 'checkbox' && item.raw) {
                    tasks.push({text: item.raw.trim(), completed: item.value === true});
                }
            });
            console.log('ðŸ”§ DEBUG: Extracted tasks', {count: tasks.length});
            return tasks;
        }

        // 8. Extract Metadata (simplified)
        function extractMetadata(supplemental) {
            const meta = {contact: '', assignees: '', location: '', links: [], media: null};
            if (!Array.isArray(supplemental)) return meta;
            supplemental.forEach(item => {
                if (item.type !== 'text' || !item.raw) return;
                const text = item.raw.trim();
                if (text.startsWith('contact:')) meta.contact = text.replace('contact:', '').trim();
                if (text.startsWith('assignees:')) meta.assignees = text.replace('assignees:', '').trim().replace(/[\[\]]/g, '');
                if (text.startsWith('location:')) meta.location = text.replace('location:', '').trim();
                if (text.startsWith('[') && text.includes('](')) {
                    const [textPart, urlPart] = text.split('](');
                    meta.links.push({text: textPart.slice(1), url: urlPart.slice(0, -1)});
                }
                if (text.startsWith('![')) {
                    const [altPart, urlPart] = text.split('](');
                    meta.media = {alt: altPart.slice(2), url: urlPart.slice(0, -1)};
                }
            });
            return meta;
        }

        // 9. Recursively Extract Events (v0.16.3-focused: handles "fn" type nodes)
        function extractEvents(children, section = null, group = null) {
            const events = [];
            if (!Array.isArray(children)) return events;

            for (const child of children) {
                console.log('ðŸ” DEBUG: Processing node', {type: child.style || child.constructor.name});

                // Section node (v0.16.3 uses "fn" type for sections/groups)
                if (child.style === 'section' && child.title) {
                    const newSection = {id: child.id || Date.now().toString(), name: child.title};
                    events.push(...extractEvents(child.children || [], newSection, group));
                }
                // Group node (v0.16.3 uses "fn" type for sections/groups)
                else if (child.style === 'group' && child.title) {
                    const newGroup = {id: child.id || Date.now().toString(), name: child.title, tags: child.tags || []};
                    events.push(...extractEvents(child.children || [], section, newGroup));
                }
                // Event node (v0.16.3 uses "ri" type for events)
                else if (child.dateRangeIso && child.firstLine) {
                    const supplemental = child.supplemental || [];
                    const event = {
                        id: child.id || Date.now().toString(),
                        title: child.firstLine.restTrimmed || 'Untitled',
                        dateRange: {
                            start: child.dateRangeIso.fromDateTimeIso,
                            end: child.dateRangeIso.toDateTimeIso
                        },
                        section,
                        group,
                        tasks: extractTasks(supplemental),
                        meta: extractMetadata(supplemental)
                    };
                    events.push(event);
                    console.log('âœ… DEBUG: Extracted event', {title: event.title, section: section?.name, group: group?.name});
                }
                // Recurse into children
                else if (child.children) {
                    events.push(...extractEvents(child.children, section, group));
                }
            }
            return events;
        }

        // 10. Generate Color for Tag
        function generateTagColor(tagName, existingTags) {
            const colors = COLOR_PALETTES[currentPalette];
            const colorIndex = existingTags.length % colors.length;
            return colors[colorIndex];
        }

        // 11. Extract Parsed Data (FORCE log raw Parser output + fix tag extraction + auto-color generation)
        function extractParsedData(parseResult) {
            // ðŸ”´ FORCE show raw Parser output (critical for debugging)
            console.log('ðŸ“‹ DEBUG: RAW Parser Output (v0.16.3)', parseResult);

            const data = {
                title: parseResult.header?.title || 'Untitled',
                timezone: parseResult.header?.timezone || 'UTC',
                tags: [],
                sections: [],
                events: []
            };

            // Extract explicit tags (FIX: v0.16.3 still uses legacy format: )Tag: ')Color')
            if (parseResult.header) {
                Object.entries(parseResult.header).forEach(([key, value]) => {
                    // Handle legacy format (from raw output: )Launch: ')2196F3')
                    if (key.startsWith(')') && typeof value === 'string' && value.startsWith("')") && value.endsWith("'")) {
                        const tagName = key.slice(1); // Remove leading ")"
                        const tagColor = `#${value.slice(2, -1)}`; // Extract color (remove ") and ')
                        data.tags.push({name: tagName, color: tagColor});
                        console.log('ðŸ”– DEBUG: Extracted legacy tag', {tagName, tagColor});
                    }
                    // Fallback for standard format (if Parser ever switches)
                    else if (key.startsWith('#') && value.startsWith('#')) {
                        data.tags.push({name: key.slice(1), color: value});
                        console.log('ðŸ”– DEBUG: Extracted standard tag', {tagName: key.slice(1), tagColor: value});
                    }
                });
            }

            // Extract events (from root events.children - v0.16.3 uses "fn" type root)
            const rootChildren = parseResult.events?.children || [];
            data.events = extractEvents(rootChildren);

            // Auto-generate colors for tags found in events but not explicitly defined
            const allTagsInEvents = new Set();
            data.events.forEach(event => {
                if (event.group?.tags) {
                    event.group.tags.forEach(tag => allTagsInEvents.add(tag));
                }
            });

            allTagsInEvents.forEach(tagName => {
                if (!data.tags.find(t => t.name === tagName)) {
                    const color = generateTagColor(tagName, data.tags);
                    data.tags.push({name: tagName, color});
                    console.log('ðŸŽ¨ DEBUG: Auto-generated color for tag', {tagName, color});
                }
            });

            console.log('ðŸ”– DEBUG: All extracted tags', {tags: data.tags});
            console.log('ðŸ“Š DEBUG: Final extracted events', {count: data.events.length});

            // Extract unique sections
            data.sections = [...new Map(data.events.map(e => e.section ? [e.section.id, e.section] : null).filter(Boolean))].map(([_, s]) => s);
            return data;
        }

        // 12. Map to TimelineJS (FIX: Math.min/Math.max error with Date objects)
        function mapToTimelineJS(parseResult) {
            const data = extractParsedData(parseResult);
            const timelineJson = {
                title: {text: {headline: data.title, text: `Timezone: ${data.timezone}`}},
                events: [],
                eras: [],
                tags: Object.fromEntries(data.tags.map(t => [t.name, t.color]))
            };

            // Add sections as eras (FIX: Use timestamps for Math.min/Math.max)
            data.sections.forEach(section => {
                const sectionEvents = data.events.filter(e => e.section?.id === section.id);
                if (sectionEvents.length === 0) return;

                // Step 1: Convert dates to TIMESTAMPS (fixes Math.min/Math.max error)
                const startTimestamps = sectionEvents
                    .map(e => e.dateRange.start)
                    .filter(Boolean)
                    .map(d => new Date(d).getTime()); // Get numeric timestamp

                const endTimestamps = sectionEvents
                    .map(e => e.dateRange.end || e.dateRange.start)
                    .filter(Boolean)
                    .map(d => new Date(d).getTime()); // Get numeric timestamp

                // Step 2: Calculate earliest start and latest end (using timestamps)
                const earliestStart = new Date(Math.min(...startTimestamps));
                const latestEnd = new Date(Math.max(...endTimestamps));

                // Step 3: Normalize dates
                const start = normalizeDate(earliestStart.toISOString());
                const end = normalizeDate(latestEnd.toISOString());

                if (start && end) {
                    timelineJson.eras.push({
                        start_date: start,
                        end_date: end,
                        text: {headline: section.name},
                        background: {color: '#f0f0f0'}
                    });
                    console.log('ðŸ“… DEBUG: Added section era', {section: section.name, start, end});
                }
            });

            // Add events (FIX: Ensure group color works)
            data.events.forEach((event, idx) => {
                const start = normalizeDate(event.dateRange.start);
                const end = event.dateRange.end ? normalizeDate(event.dateRange.end) : null;
                if (!start) return;

                // Event color (FIX: Prioritize group tag, fallback to dark gray)
                let color = '#808080'; // Dark gray fallback (no more white)
                if (event.group?.tags?.length) {
                    const groupTag = event.group.tags[0];
                    color = timelineJson.tags[groupTag] || color;
                }

                // Build details
                let details = '';
                if (event.group?.tags?.length) details += `<p><strong>Tags:</strong> #${event.group.tags.join(', #')}</p>`;
                if (event.tasks.length) {
                    details += '<ul style="padding-left: 1.5rem;">';
                    event.tasks.forEach(t => details += `<li>[${t.completed ? 'âœ“' : ' '}] ${t.text}</li>`);
                    details += '</ul>';
                }
                if (event.meta.contact) details += `<p><strong>Contact:</strong> ${event.meta.contact}</p>`;
                if (event.meta.assignees) details += `<p><strong>Assignees:</strong> ${event.meta.assignees}</p>`;
                if (event.meta.location) details += `<p><strong>Location:</strong> ${event.meta.location}</p>`;
                event.meta.links.forEach(link => details += `<p><strong>Link:</strong> <a href="${link.url}" target="_blank">${link.text}</a></p>`);

                // Add event
                const timelineEvent = {
                    start_date: start,
                    text: {headline: `[${event.section?.name || 'Other'}] ${event.title}`, text: details},
                    group: event.group?.name || 'Default',
                    background: {color: color},
                    unique_id: event.id
                };
                if (end) timelineEvent.end_date = end;
                if (event.meta.media) timelineEvent.media = {url: event.meta.media.url, caption: event.meta.media.alt};
                timelineJson.events.push(timelineEvent);
                console.log(`âœ… DEBUG: Added timeline event ${idx + 1}`, {title: event.title, color: color});
            });

            // Empty state
            if (timelineJson.events.length === 0) {
                timelineJson.events.push({
                    start_date: normalizeDate(new Date().toISOString()),
                    text: {headline: 'No Events Found', text: 'Add valid events with dates'},
                    group: 'Default'
                });
            }
            return timelineJson;
        }

        // 13. Render Timeline
        function renderTimeline(timelineJson) {
            if (timelineInstance?.destroy) timelineInstance.destroy();
            try {
                timelineInstance = new TL.Timeline('timeline', timelineJson, {
                    scale: 'human',
                    display_date: {format: 'MMM DD, YYYY'},
                    height: '100%',
                    track_height: 90
                });
                console.log('âœ… DEBUG: Timeline rendered successfully');
                successMessage.style.display = 'block';
                parseError.style.display = 'none';
            } catch (err) {
                timelineContainer.innerHTML = `<div class="empty-state">Timeline Error: ${err.message}</div>`;
                console.error('âŒ DEBUG: Timeline render error:', err);
            }
        }

        // 14. Main Update Workflow (FORCE log every step)
        function updateTimeline() {
            if (!parseMarkwhen || !dateFns) {
                console.log('âš ï¸ DEBUG: Update skipped - dependencies missing');
                return;
            }

            const input = editor.value.trim();
            console.log('ðŸš€ DEBUG: Starting parse', {inputLength: input.length});
            parseError.style.display = 'none';
            successMessage.style.display = 'none';

            try {
                // Parse and FORCE log result
                const parseResult = parseMarkwhen(input);
                console.log('ðŸ“‹ DEBUG: Parser result received', {hasEvents: !!parseResult.events});

                // Map and render
                const timelineJson = mapToTimelineJS(parseResult);
                renderTimeline(timelineJson);
            } catch (err) {
                parseError.style.display = 'block';
                parseError.textContent = `Parse Error: ${err.message}`;
                console.error('âŒ DEBUG: Parse/render error:', err);
            }
        }

        // 15. Editor Listener
        let debounceTimer;
        editor.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(updateTimeline, 500);
        });

        // Initial Render
        console.log('ðŸ”„ DEBUG: Triggering initial render');
        if (parseMarkwhen && dateFns) updateTimeline();
    </script>
</body>

</html>